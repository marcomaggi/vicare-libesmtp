\input texinfo.tex
@c %**start of header
@setfilename vicare-libesmtp.info
@settitle Libesmtp for Vicare
@c %**end of header

@include version.texi
@include macros.texi

@macro libesmtpref{NODE, TITLE}
@xref{\NODE\,\TITLE\,\TITLE\,libesmtp}
@end macro


@macro libesmtp{}
libESMTP
@end macro

@macro etrn{}
@acronym{ETRN}
@end macro

@macro auth{}
@acronym{AUTH}
@end macro

@macro gsasl{}
@acronym{GSASL}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @libesmtp{} for Vicare

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare/@libesmtp{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-libesmtp

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi.ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2013


@set LIBESMTP_VERSION           1.0.7rc1
@set LIBESMTP_URL               @url{http:/@//@/www.stafford.uklinux.net/@/libesmtp/@/}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @version{} of @value{PACKAGE}, a
distribution of C and Scheme libraries for Vicare Scheme, an @rnrs{6}
compliant Scheme implementation; it provides bindings for the
@libesmtp{} C language library.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://code.google.com/p/vicare-scheme/downloads/list}

@noindent
development takes place at:

@center @url{http://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}

@noindent
@libesmtp{} is available at:

@center @value{LIBESMTP_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-libesmtp: (vicare-libesmtp). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Libesmtp version informations.
* plain::                       Plain programming interface.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


Vicare Scheme is an @rnrs{6} compliant Scheme language implementation in
the form of a native compiler for x86 architectures, officially
supporting @gnu{}+Linux systems.  @value{PACKAGE} is a distribution of C
language and Scheme language libraries for Vicare Scheme; it provides
bindings for the @libesmtp{} C language library.

The last time the author bothered to update this paragraph, he had
tested @libesmtp{} version @value{LIBESMTP_VERSION}; the @libesmtp{}
library is available at:

@center @value{LIBESMTP_URL}

The package installs a C language library implementing wrapper C
functions for the C language @libesmtp{} library; on top of this, the
Scheme library @library{vicare mail libesmtp} exports one binding for
each @libesmtp{} public function; additionally the library
@library{vicare mail libesmtp constants} exports one binding for each
constant value defined in the C language header @file{libesmtp.h}.

The following Scheme libraries are installed:

@table @library
@item vicare mail libesmtp
@cindex Library @library{vicare mail libesmtp}
@cindex @library{vicare mail libesmtp}, library
It exports one binding for each @libesmtp{} public function.  All the
Scheme function names are directly derived from the C function names by
replacing underscore characters @samp{_} with dash characters @samp{-};
so @cfunc{smtp_version} becomes @func{smtp-version}.

@item vicare mail libesmtp unsafe-capi
@cindex Library @library{vicare mail libesmtp unsafe-capi}
@cindex @library{vicare mail libesmtp unsafe-capi}, library
It exports one syntax binding for each @libesmtp{} public function.  All
the Scheme syntax names are directly derived from the C function names
by replacing underscore characters @samp{_} with dash characters
@samp{-}; so @cfunc{smtp_version} becomes @func{smtp-version}.

These syntaxes expand to a direct call to the C language wrapper
functions in the @value{PACKAGE} library; they are not meant to be
called in normal usage of the package.

@item vicare mail libesmtp constants
@cindex Library @library{vicare mail libesmtp constants}
@cindex @library{vicare mail libesmtp constants}, library
It exports one binding for each constant value defined in the C language
header @file{libesmtp.h}.

@item vicare mail libesmtp features
@cindex Library @library{vicare mail libesmtp features}
@cindex @library{vicare mail libesmtp features}, library
It exports one identifier syntax binding for each @code{HAVE_} constant
defined by the @command{configure} script, expanding to @true{} or
@false{}.
@end table

Scheme libraries are installed under the directory:

@center @file{$(libdir)/vicare-scheme}

After installation, under the directory @code{$libexecdir/$PACKAGE}, a
script @file{compile-all.sps} can be executed to precompile the
installed libraries; for example:

@example
$ sudo vicare \
   --fasl-directory /var/cache/vicare-scheme \
   --compile-dependencies \
      /usr/local/libexec/vicare-libesmtp/compile-all.sps
@end example

This document contains only a brief description of the functions: refer
to the @libesmtp{}'s documentation for details.

@c page
@node version
@chapter @libesmtp{} version informations


The installed C library follows version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.

The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun vicare-libesmtp-version-interface-current
@defunx vicare-libesmtp-version-interface-revision
@defunx vicare-libesmtp-version-interface-age
Return a fixnum representing a version number.
@end defun


@defun vicare-libesmtp-version
Return a Scheme string representing the version number.
@end defun

@c ------------------------------------------------------------

@defun smtp-version
Return a Scheme string representing the version number of @libesmtp{}.
In the very unlikely case that this function fails: @false{} is
returned.
@end defun

@c page
@node plain
@chapter Plain programming interface


@cindex Library @library{vicare mail libesmtp}
@cindex @library{vicare mail libesmtp}, library


@menu
* plain examples::              Usage examples.
* plain structs::               Data structures.
* plain errors::                Library errors.
* plain sessions::              Session management.
* plain messages::              Message management.
* plain recipients::            Recipient management.
* plain headers::               Headers management.
* plain status::                Session results.
* plain constants::             Converting constants to symbols.
* plain data::                  Application data.
* plain extensions::            @smtp{} extensions.
@c * plain auth::                  @auth{} module.
@end menu

@c page
@node plain examples
@section Usage examples


@menu
* plain examples simple::       Simple message mailing.
* plain examples cb::           Simple message mailing using the full
                                message callback.
* plain examples debug::        Simple message mailing with
                                debug callbacks.
@end menu

@c page
@node plain examples simple
@subsection Simple message mailing


The following program sends a message with no frills; make use of
@func{smtp-set-message-str} to feed the message to @libesmtp{}:

@smallexample
#!r6rs
(import (rnrs)
  (only (vicare language-extensions)
        pretty-print
        fprintf)
  (prefix (vicare mail libesmtp) esmtp.)
  (prefix (vicare mail libesmtp constants) esmtp.)
  (prefix (vicare ffi) ffi.)
  (only (vicare syntactic-extensions)
        unwind-protect))

(define local-hostname
  "localhost")

(define smtp-server
  "localhost:smtp")

(define sender-mailbox
  "marco@@localhost")

(define recipient-mailbox
  "marco@@localhost")

(define message-text
  "From: <marco@@localhost>\r\n\
   To: <marco@@localhost>\r\n\
   Subject: demo of vicare/libesmtp\r\n\
   \r\n\
   This is the text.\r\n")

(let* ((sex  (esmtp.smtp-create-session))
       (msg  (esmtp.smtp-add-message sex))
       (rec  (esmtp.smtp-add-recipient msg recipient-mailbox))
       (cstr (ffi.string->cstring message-text)))
  (unwind-protect
      (begin
        (esmtp.smtp-set-server sex smtp-server)
        (esmtp.smtp-set-reverse-path msg sender-mailbox)
        (esmtp.smtp-set-hostname sex local-hostname)
        (esmtp.smtp-set-message-str msg cstr)
        (esmtp.smtp-start-session sex)
        (fprintf (current-error-port)
                 "recipient complete? ~a\n"
                 (esmtp.smtp-recipient-check-complete rec)))
    (esmtp.smtp-destroy-session sex)))
@end smallexample

@c page
@node plain examples cb
@subsection Simple message mailing using the full message callback


The following program sends a message with no frills; make use of
@func{smtp-set-messagecb} to feed the message to @libesmtp{}:

@smallexample
#!r6rs
(import (rnrs)
  (only (vicare language-extensions)
        pretty-print
        fprintf)
  (prefix (vicare mail libesmtp) esmtp.)
  (prefix (vicare mail libesmtp constants) esmtp.)
  (prefix (vicare ffi) ffi.)
  (only (vicare syntactic-extensions)
        unwind-protect))

(define local-hostname
  "localhost")

(define smtp-server
  "localhost:smtp")

(define sender-mailbox
  "marco@@localhost")

(define recipient-mailbox
  "marco@@localhost")

(define message-text
  "From: <marco@@localhost>\r\n\
   To: <marco@@localhost>\r\n\
   Subject: demo of vicare/libesmtp\r\n\
   \r\n\
   This is the text.\r\n")

(define (make-message-cb message-text)
  (let ((cstr.ptr   #f)
        (cstr.len   #f))
    (lambda (unused len.ptr)
      (cond ((ffi.pointer-null? len.ptr)
             ;;If LEN.PTR  is set to NULL:  this call is to  ask the
             ;;application to  rewind the message; the  return value
             ;;is not used, but it must be a pointer.
             (set! cstr.ptr (ffi.string->cstring message-text))
             (set! cstr.len (ffi.strlen cstr.ptr))
             (ffi.null-pointer))

            (cstr.len
             ;;If LEN.PTR is  not NULL: this callback  must return a
             ;;pointer to  the start of  the next message  chunk and
             ;;set the location referenced  by LEN.PTR to the number
             ;;of octets of data in the buffer.
             (ffi.pointer-set-c-signed-int! len.ptr 0 cstr.len)
             (set! cstr.len #f)
             cstr.ptr)

            (else
             ;;The callback  is called  repeatedly until  the entire
             ;;message  has been  processed.  When  all the  message
             ;;data has been read the callback must return NULL.
             (ffi.pointer-set-c-signed-int! len.ptr 0 0)
             (ffi.null-pointer))))))

(let* ((sex  (esmtp.smtp-create-session))
       (msg  (esmtp.smtp-add-message sex))
       (rec  (esmtp.smtp-add-recipient msg recipient-mailbox))
       (mcb  (esmtp.make-smtp-messagecb
                (make-message-cb message-text))))
  (unwind-protect
      (begin
        (esmtp.smtp-set-server sex smtp-server)
        (esmtp.smtp-set-reverse-path msg sender-mailbox)
        (esmtp.smtp-set-hostname sex local-hostname)
        (esmtp.smtp-set-messagecb msg mcb)
        (esmtp.smtp-start-session sex)
        (fprintf (current-error-port)
                 "recipient complete? ~a\n"
                 (esmtp.smtp-recipient-check-complete rec)))
    (esmtp.smtp-destroy-session sex)
    (ffi.free-c-callback mcb)))
@end smallexample

@c page
@node plain examples debug
@subsection Simple message mailing with debug callbacks


The following program sends a message and shows debugging callbacks;
make use of @func{smtp-set-message-str} to feed the message to
@libesmtp{}:

@smallexample
#!r6rs
(import (rnrs)
  (only (vicare language-extensions)
        pretty-print
        fprintf)
  (prefix (vicare mail libesmtp) esmtp.)
  (prefix (vicare mail libesmtp constants) esmtp.)
  (prefix (vicare ffi) ffi.)
  (only (vicare syntactic-extensions)
        unwind-protect))

(define local-hostname
  "localhost")

(define smtp-server
  "localhost:smtp")

(define sender-mailbox
  "marco@@localhost")

(define recipient-mailbox
  "marco@@localhost")

(define message-text
  "From: <marco@@localhost>\r\n\
   To: <marco@@localhost>\r\n\
   Subject: demo of vicare/libesmtp\r\n\
   \r\n\
   This is the text.\r\n")

(define (monitor-cb buf.ptr buf.len writing)
  (fprintf (current-error-port)
           "monitor: ~a, ~a"
           (esmtp.smtp-cb->symbol writing)
           (ffi.cstring->string buf.ptr buf.len)))

(define (event-cb session event-no)
  (fprintf (current-error-port)
           "event: ~a\n"
           (esmtp.smtp-event->symbol event-no)))

(let* ((sex  (esmtp.smtp-create-session))
       (msg  (esmtp.smtp-add-message sex))
       (rec  (esmtp.smtp-add-recipient msg recipient-mailbox))
       (cstr (ffi.string->cstring message-text))
       (mcb  (esmtp.make-smtp-monitorcb monitor-cb))
       (ecb  (esmtp.make-smtp-eventcb   event-cb)))
  (unwind-protect
      (begin
        (esmtp.smtp-set-monitorcb sex mcb #t)
        (esmtp.smtp-set-eventcb   sex ecb)
        (esmtp.smtp-set-server sex smtp-server)
        (esmtp.smtp-set-reverse-path msg sender-mailbox)
        (esmtp.smtp-set-hostname sex local-hostname)
        (esmtp.smtp-set-message-str msg cstr)
        (esmtp.smtp-start-session sex)
        (fprintf (current-error-port)
                 "recipient complete? ~a\n"
                 (esmtp.smtp-recipient-check-complete rec)))
    (esmtp.smtp-destroy-session sex)
    (ffi.free-c-callback mcb)
    (ffi.free-c-callback ecb)))
@end smallexample

@c page
@node plain structs
@section Data structures


@menu
* plain structs session::       Session data structures.
* plain structs message::       Message data structures.
* plain structs recipient::     Recipient data structures.
* plain structs etrn node::     @etrn{} node data structures.
* plain structs auth ctx::      @auth{} context structures.
* plain structs status::        Status data structures.
@end menu

@c page
@node plain structs session
@subsection Session data structures


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@deftp {Struct Type} smtp-session
@cindex @var{session} argument
@cindex Argument @var{session}
An opaque Scheme structure holding an instance of the C language type
@code{smtp_session_t}, it references a session.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{session}.

There are two categories of @code{smtp-session} instances: those who own
the underlying @smtp{} session and those who merely reference it.

@itemize
@item
@code{smtp-session} instances returned by @func{smtp-create-session} do
own the session.  When instances of this category are garbage collected
or when @func{smtp-destroy-session} is applied to them: the session is
closed, all the associated data is finalised; any error is ignored in
this procedure.

@c @item
@c @code{smtp-session} instances returned by
@c @func{smtp-session-context-db-handle} do @strong{not} own the database
@c connection.  When instances of this category are garbage collected or
@c when @func{smtp-session-close} is applied to them: the database
@c connection left open, all the associated @code{smtp-session-stmt}
@c instances are finalised and all the associated @code{smtp-session-blob}
@c instances are closed; any error is ignored in this procedure.
@end itemize
@end deftp


@defun smtp-session? @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-session};
otherwise return @false{}.
@end defun


@defun smtp-session?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-session} and
the @code{smtp_session_t} it represents is open; otherwise return
@false{}.
@end defun


@defun smtp-session-destructor @var{session}
@defunx set-smtp-session-destructor! @var{session} @var{func}
Retrieve or set a destructor function associated to the @var{session}.

Whenever the @var{session} is closed, either explicitly with
@func{smtp-destroy-session} or implicitly by the garbage collector,
@var{func} is applied to @var{session} before the internal state of
@var{session} is finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{session}; if we do:

@example
(define session ...)
(set-smtp-session-destructor! session
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((sex)
       (destroy state))
      (()
       state))))

(let ((state ((smtp-session-destructor session))))
  (do-something-with session state))
@end example

@noindent
we can easily associate values to @var{session}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} smtp-session @var{obj}
@deffnx {Validation Clause} false-or-smtp-session @var{obj}
Succeed if @var{obj} satisfies the predicate @func{smtp-session?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} smtp-session/alive @var{obj}
@deffnx {Validation Clause} false-or-smtp-session/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{smtp-session?/alive};
the second clause also accepts @false{}.
@end deffn

@c page
@node plain structs message
@subsection Message data structures


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@deftp {Struct Type} smtp-message
@cindex @var{message} argument
@cindex Argument @var{message}
An opaque Scheme structure holding an instance of the C language type
@code{smtp_message_t}, it references a message associated to an @smtp{}
session.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{message}.

Instances of type @code{smtp-message} never own the underlying message;
when these instances are garbage collected or when
@func{smtp-destroy-session} is applied to the owning session: the
message is closed, all the associated data is finalised; any error is
ignored in this procedure.
@end deftp


@defun smtp-message? @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-message};
otherwise return @false{}.
@end defun


@defun smtp-message?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-message} and
the @code{smtp_message_t} it represents is open; otherwise return
@false{}.
@end defun


@defun smtp-message-destructor @var{message}
@defunx set-smtp-message-destructor! @var{message} @var{func}
Retrieve or set a destructor function associated to the @var{message}.

Whenever the @var{message} is finalised: @var{func} is applied to
@var{message} before the internal state of @var{message} is finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{message}; if we do:

@example
(define connection ...)
(set-smtp-message-destructor! connection
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((conn)
       (destroy state))
      (()
       state))))

(let ((state ((smtp-message-destructor connection))))
  (do-something-with connection state))
@end example

@noindent
we can easily associate values to @var{message}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} smtp-message @var{obj}
@deffnx {Validation Clause} false-or-smtp-message @var{obj}
Succeed if @var{obj} satisfies the predicate @func{smtp-message?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} smtp-message/alive @var{obj}
@deffnx {Validation Clause} false-or-smtp-message/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{smtp-message?/alive};
the second clause also accepts @false{}.
@end deffn

@c page
@node plain structs recipient
@subsection Recipient data structures


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@deftp {Struct Type} smtp-recipient
@cindex @var{recipient} argument
@cindex Argument @var{recipient}
An opaque Scheme structure holding an instance of the C language type
@code{smtp_recipient_t}, it references a message recipient associated to
a message.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{recipient}.

Instances of type @code{smtp-recipient} never own the underlying
recipient; when these instances are garbage collected or when
@func{smtp-destroy-session} is applied to the session owning the
associated message: the recipient is closed, all the associated data is
finalised; any error is ignored in this procedure.
@end deftp


@defun smtp-recipient? @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-recipient};
otherwise return @false{}.
@end defun


@defun smtp-recipient?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-recipient} and
the @code{smtp_recipient_t} it represents is open; otherwise return
@false{}.
@end defun


@defun smtp-recipient-destructor @var{recipient}
@defunx set-smtp-recipient-destructor! @var{recipient} @var{func}
Retrieve or set a destructor function associated to the @var{recipient}.

Whenever the @var{recipient} is finalised: @var{func} is applied to
@var{recipient} before the internal state of @var{recipient} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{recipient}; if we do:

@example
(define connection ...)
(set-smtp-recipient-destructor! connection
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((conn)
       (destroy state))
      (()
       state))))

(let ((state ((smtp-recipient-destructor connection))))
  (do-something-with connection state))
@end example

@noindent
we can easily associate values to @var{recipient}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} smtp-recipient @var{obj}
@deffnx {Validation Clause} false-or-smtp-recipient @var{obj}
Succeed if @var{obj} satisfies the predicate @func{smtp-recipient?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} smtp-recipient/alive @var{obj}
@deffnx {Validation Clause} false-or-smtp-recipient/alive @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{smtp-recipient?/alive}; the second clause also accepts @false{}.
@end deffn

@c page
@node plain structs etrn node
@subsection @etrn{} node data structures


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@deftp {Struct Type} smtp-etrn-node
@cindex @var{etrn-node} argument
@cindex Argument @var{etrn-node}
An opaque Scheme structure holding an instance of the C language type
@code{smtp_etrn_node_t}, it references an @etrn{} node associated to a
session.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{etrn-node}.

Instances of type @code{smtp-etrn-node} never own the underlying @etrn{}
node structure; when these instances are garbage collected or when
@func{smtp-destroy-session} is applied to the session owning the
associated message: the @etrn{} node is closed, all the associated data
is finalised; any error is ignored in this procedure.
@end deftp


@defun smtp-etrn-node? @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-etrn-node};
otherwise return @false{}.
@end defun


@defun smtp-etrn-node?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-etrn-node} and
the @code{smtp_etrn_node_t} it represents is open; otherwise return
@false{}.
@end defun


@defun smtp-etrn-node-destructor @var{etrn-node}
@defunx set-smtp-etrn-node-destructor! @var{etrn-node} @var{func}
Retrieve or set a destructor function associated to the @var{etrn-node}.

Whenever the @var{etrn-node} is finalised: @var{func} is applied to
@var{etrn-node} before the internal state of @var{etrn-node} is
finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{etrn-node}; if we do:

@example
(define connection ...)
(set-smtp-etrn-node-destructor! connection
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((conn)
       (destroy state))
      (()
       state))))

(let ((state ((smtp-etrn-node-destructor connection))))
  (do-something-with connection state))
@end example

@noindent
we can easily associate values to @var{etrn-node}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} smtp-etrn-node @var{obj}
@deffnx {Validation Clause} false-or-smtp-etrn-node @var{obj}
Succeed if @var{obj} satisfies the predicate @func{smtp-etrn-node?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} smtp-etrn-node/alive @var{obj}
@deffnx {Validation Clause} false-or-smtp-etrn-node/alive @var{obj}
Succeed if @var{obj} satisfies the predicate
@func{smtp-etrn-node?/alive}; the second clause also accepts @false{}.
@end deffn

@c page
@node plain structs auth ctx
@subsection @auth{} context structures


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@deftp {Struct Type} auth-context
@cindex @var{auth-ctx} argument
@cindex Argument @var{auth-ctx}
An opaque Scheme structure holding an instance of the C language type
@code{auth_context_t}, it references an @auth{} context data structure.

When instances of this type are used as arguments to functions: this
documentation identifies them as @var{auth-ctx}.

There are two categories of @code{auth-context} instances: those
who own the underlying @auth{} context and those who merely reference
it.

@itemize
@item
@code{auth-context} instances returned by @func{auth-create-context} do
own the context.  When instances of this category are garbage collected
or when @func{auth-destroy-context} is applied to them: the context is
closed, all the associated data is finalised; any error is ignored in
this procedure.
@end itemize
@end deftp


@defun auth-context? @var{obj}
Return @true{} if @var{obj} is an instance of @code{auth-context};
otherwise return @false{}.
@end defun


@defun auth-context?/alive @var{obj}
Return @true{} if @var{obj} is an instance of @code{auth-context} and
the @code{auth_context_t} it represents is open; otherwise return
@false{}.
@end defun


@defun auth-context-destructor @var{auth-ctx}
@defunx set-auth-context-destructor! @var{auth-ctx} @var{func}
Retrieve or set a destructor function associated to the @var{auth-ctx}.

Whenever the @var{auth-ctx} is finalised: @var{func} is applied to
@var{auth-ctx} before the internal state of @var{auth-ctx} is finalised.

Notice that @var{func} can do anything, not only destroy some state
associated to @var{auth-ctx}; if we do:

@example
(define connection ...)
(set-auth-context-destructor! connection
  (let ((state (make-some-data-struct)))
    (case-lambda
      ((conn)
       (destroy state))
      (()
       state))))

(let ((state ((auth-context-destructor connection))))
  (do-something-with connection state))
@end example

@noindent
we can easily associate values to @var{auth-ctx}.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} auth-context @var{obj}
@deffnx {Validation Clause} false-or-auth-context @var{obj}
Succeed if @var{obj} satisfies the predicate @func{auth-context?}; the
second clause also accepts @false{}.
@end deffn


@deffn {Validation Clause} auth-context/alive @var{obj}
@deffnx {Validation Clause} false-or-auth-context/alive @var{obj}
Succeed if @var{obj} satisfies the predicate @func{auth-context?/alive};
the second clause also accepts @false{}.
@end deffn

@c page
@node plain structs status
@subsection Status data structures


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@deftp {Struct Type} smtp-status
Type of data structure mirroring the C language type
@code{smtp_status_t}.  It has the following fields:

@table @code
@item code
Exact integer in the range of the C language type @code{signed int};
@smtp{} protocol status code.

@item text
Scheme string; text from the server.

@item enh-class
@itemx enh-subject
@itemx enh-detail
Exact integers in the range of the C language type @code{signed int};
@rfc{} 2034 enhanced status code triplet.
@end table
@end deftp


@defun make-smtp-status @var{code} @var{text} @var{enh-class} @var{enh-subject} @var{enh-detail}
Build and return a new instance of @code{smtp-status}.
@end defun


@defun smtp-status? @var{obj}
Return @true{} if @var{obj} is an instance of @code{smtp-status};
otherwise return @false{}.
@end defun


@defun smtp-status-code @var{status}
@defunx smtp-status-text @var{status}
@defunx smtp-status-enh-class @var{status}
@defunx smtp-status-enh-subject @var{status}
@defunx smtp-status-enh-detail @var{status}
Accessors for the fields of @code{smtp-status} instances.
@end defun


@defun set-smtp-status-code! @var{status} @var{value}
@defunx set-smtp-status-text! @var{status} @var{value}
@defunx set-smtp-status-enh-class! @var{status} @var{value}
@defunx set-smtp-status-enh-subject! @var{status} @var{value}
@defunx set-smtp-status-enh-detail! @var{status} @var{value}
Mutators for the fields of @code{smtp-status} instances.
@end defun

@c ------------------------------------------------------------

@subsubheading Arguments validation

The following bindings are meant to be used along the library
@library{vicare arguments validation}.


@deffn {Validation Clause} smtp-status @var{obj}
@deffnx {Validation Clause} false-or-smtp-status @var{obj}
Succeed if @var{obj} satisfies the predicate @func{smtp-status?}; the
second clause also accepts @false{}.
@end deffn

@c page
@node plain errors
@section Library errors


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-errno
Return an exact integer representing the error code for the most recent
@libesmtp{} @api{} call.  The returned value represents one the of the
@code{SMTP_ERR_} constants or zero if no error occurred.
@end defun


@defun smtp-strerror @var{errno}
Given the return value of a call to @var{errno}: return a Scheme string
representing the error description.  If an error occurs: return
@false{}.
@end defun

@c page
@node plain sessions
@section Session management


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-create-session
Build and return a new instance of type @code{smtp-session}.  If an
error occurs: return @false{}.
@end defun


@defun smtp-destroy-session @var{session}
Finalise the @var{session} releasing all the associated resources;
return unspecified values.  @smtp{} @auth{} and @gsasl{} contexts are
automatically unregistered from @var{session}.
@end defun


@defun smtp-start-session @var{session}
Run an @smtp{} protocol session.  If successful return @true{},
otherwise return @false{}.
@end defun

@c ------------------------------------------------------------

@defun smtp-set-hostname @var{session}
@defunx smtp-set-hostname @var{session} @var{local-hostname}
Set @var{local-hostname} as local hostname for @var{session}; if
successful return @true{}, else return @false{}.

The optional @var{local-hostname} must be @false{} or a general C buffer
argument holding an @asciiz{} string; when @false{} or not given:
@cnull{} is handed to the @libesmtp{} function.  @GenCStringsRef{}
@end defun


@defun smtp-set-server @var{session} @var{remote-server}
Set @var{remote-server} as remote server specification for
@var{session}; if successful return @true{}, else return @false{}.

@var{local-hostname} must be a general C buffer argument holding an
@asciiz{} string.  @GenCStringsRef{}
@end defun


@defun smtp-set-timeout @var{session} @var{which} @var{value}
Set the timeouts for @var{session}.  If successful return @true{}, else
return @false{}.

@var{which} must be an exact integer in the range of the C language type
@code{signed int}, selecting the timeout to set; the integer must
represent a constant among:

@example
Timeout_GREETING        Timeout_ENVELOPE
Timeout_DATA            Timeout_TRANSFER
Timeout_DATA2
@end example

@noindent
the constant can be optionally combined with a bitwise inclusive OR with
the constant @code{Timeout_OVERRIDE_RFC2822_MINIMUM}.

@var{value} must be an exact integer in the range of the C language type
@code{signed long} representing a number of milliseconds.
@end defun

@c ------------------------------------------------------------

@subsubheading The event callback


@defun smtp-set-eventcb @var{session} @var{c-callback}
Register a callback to notify the application about events.  If
successful return @true{}, else return @false{}.

@var{c-callback} must be the return value of a call to
@func{make-smtp-eventcb}.
@end defun


@defun make-smtp-eventcb @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as
@code{smtp_eventcb_t} callback; the returned pointer must be released
with a call to @func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept @math{2} arguments:

@enumerate
@item
An instance of @code{smtp-session} referencing the invoking session.
This instance does @strong{not} own the underlying session.

@item
An exact integer representing the event.
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{(void)} to the caller.
@var{user-scheme-callback} should take care of handling its own
exceptions.
@end itemize
@end defun

@c ------------------------------------------------------------

@subsubheading The monitor callback


@defun smtp-set-monitorcb @var{session} @var{c-callback} @var{headers}
Set a callback for tracing the @smtp{} protocol session.  If successful
return @true{}, otherwise return @false{}.

@var{c-callback} must be the return value of a call to
@func{make-smtp-monitorcb}.

@var{headers} can be any object: when true the callback is used to
display the message headers.
@end defun


@defun make-smtp-monitorcb @var{user-scheme-function}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as
@code{smtp_monitorcb_t} callback; the returned pointer must be released
with a call to @func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept @math{3} arguments:

@enumerate
@item
A pointer object referencing a C string buffer.

@item
An exact integer, in the range of the C language type @code{signed int},
representing the number of characters in the buffer.

@item
An exact integer representing one of the constants:

@example
SMTP_CB_READING
SMTP_CB_WRITING
SMTP_CB_HEADERS
@end example
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{(void)} to the caller.
@var{user-scheme-callback} should take care of handling its own
exceptions.
@end itemize
@end defun

@c page
@node plain messages
@section Message management


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-add-message @var{session}
Add a new message to @var{session} to be delivered to the remote server.
If successful: return a new instance of @code{smtp-message}; else return
@false{}.
@end defun


@defun smtp-enumerate-messages @var{session} @var{c-callback}
For each @code{smtp_message_t} in the @code{smtp_session_t} referenced
by @var{session}: call the @var{c-callback} function.  Return
unspecified values.

@var{c-callback} must be the return value of a call to
@func{make-smtp-enumerate-messagecb}.
@end defun


@defun make-smtp-enumerate-messagecb @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as
@code{smtp_enumerate_messagecb_t} callback; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept @math{1} argument:

@enumerate
@item
An instance of @code{smtp-message} referencing a message in the invoking
session.  This instance is @strong{not} an object returned by
@func{smtp-add-message}.
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{(void)} to the caller.
@var{user-scheme-callback} should take care of handling its own
exceptions.
@end itemize
@end defun


@defun smtp-enumerate-messages* @var{session} @var{scheme-callback}
Apply @var{scheme-callback} to each @code{smtp-message} registered in
@var{session}; return unspecified values.  The order of application is
undefined.

@var{scheme-callback} must be a Scheme procedure accepting a single
argument: an instance of @code{smtp-message} registered in
@var{session}.  The @code{smtp-message} instances handed to
@var{scheme-callback} are the same returned by @func{smtp-add-message}.
@end defun


@defun smtp-set-reverse-path @var{message}
@defunx smtp-set-reverse-path @var{message} @var{mailbox}
Set the reverse path mailbox for @var{message}; this mailbox is the
sender address.  If successful return @true{}, else return @false{}.

The optional @var{mailbox} must be @false{} or a general C buffer
argument holding an @asciiz{} string; when @false{} or not given:
@cnull{} is handed to the @libesmtp{} function.  @GenCStringsRef{}
@end defun

@c ------------------------------------------------------------

@defun smtp-set-messagecb @var{message} @var{c-callback}
Set the callback to read the message from an application.  If successful
return @true{}, otherwise return @false{}.

@var{c-callback} must be the return value of a call to
@func{make-smtp-messagecb}.
@end defun


@defun make-smtp-messagecb @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as
@code{smtp__messagecb_t} callback; the returned pointer must be released
with a call to @func{free-c-callback} from @library{vicare ffi}.

@var{user-scheme-callback} must accept @math{2} arguments:

@enumerate
@item
A pointer object referencing a location of type @code{void *}; to be
used by the callback function for its optional buffer.

@item
A pointer object representing @cnull{} or referencing a location of type
@code{signed int}; the referenced integer is the number of bytes
available in the message.
@end enumerate

@var{user-scheme-callback} must return a pointer object representing
@cnull{} of the next byte of the message.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns a pointer object representing @cnull{} to the caller.
@var{user-scheme-callback} should take care of handling its own
exceptions.
@end itemize
@end defun


@defun smtp-set-message-fp @var{message} @var{file-pointer}
Select a @code{FILE *} from which the message will be read.  If
successful return @true{}, otherwise return @false{}.

@var{file-pointer} must be a pointer to @code{FILE *}.
@end defun


@defun smtp-set-message-str @var{message} @var{string}
Set the message from a general C buffer.  If successful return @true{},
otherwise return @false{}.

@var{string} must be a general C buffer argument holding an @asciiz{}
string; @GenCStringsRef{}
@end defun

@c page
@node plain recipients
@section Recipient management


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-add-recipient @var{message} @var{mailbox}
Add a new recipient to @var{message} to be delivered to the remote
server.  If successful: return a new instance of @code{smtp-recipient};
else return @false{}.

The optional @var{mailbox} must be a general C buffer argument holding
an @asciiz{} string; @GenCStringsRef{}
@end defun


@defun smtp-enumerate-recipients @var{message} @var{c-callback}
For each @code{smtp_recipient_t} in the @code{smtp_message_t} referenced
by @var{message}: call the @var{c-callback} function.  If successful
return @true{}, else return @false{}.

@var{c-callback} must be the return value of a call to
@func{make-smtp-enumerate-recipientcb}.
@end defun


@defun make-smtp-enumerate-recipientcb @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as
@code{smtp_enumerate_recipientcb_t} callback; the returned pointer must
be released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept @math{2} arguments:

@enumerate
@item
An instance of @code{smtp-recipient} referencing a recipient in the
invoking message.  This instance is @strong{not} an object returned by
@func{smtp-add-recipient}.

@item
A pointer object referencing the mailbox of the recipient as @asciiz{}
string.  Such string can be converted to Scheme with a call to
@func{cstring->string} from @library{vicare ffi}.
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{(void)} to the caller.
@var{user-scheme-callback} should take care of handling its own
exceptions.
@end itemize
@end defun


@defun smtp-enumerate-recipients* @var{message} @var{scheme-callback}
Apply @var{scheme-callback} to each @code{smtp-recipient} registered in
@var{message}; return unspecified values.  The order of application is
undefined.

@var{scheme-callback} must be a Scheme procedure accepting a single
argument: an instance of @code{smtp-recipient} registered in
@var{message}.  The @code{smtp-recipient} instances handed to
@var{scheme-callback} are the same returned by @func{smtp-add-recipient}.
@end defun


@defun smtp-option-require-all-recipients @var{session} @var{obj}
Set or unset failing of message delivery if one recipient cannot be
served.  If successful return @true{}, otherwise return @false{}.

If @var{obj} is true: message delivery will fail if at least one
recipient cannot be served; if @var{obj} is @false{} message delivery
will not fail.
@end defun

@c page
@node plain headers
@section Headers management


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-set-header @var{message} @var{header-name} @vari{value}
@defunx smtp-set-header @var{message} @var{header-name} @vari{value} @varii{value}
Set a header in the @var{message}.  If successful return @true{}, else
return @false{}.

@var{header-name} must be a Scheme string representing a header name,
@strong{without} the trailing colon character.  Some headers are
specially recognised by @libesmtp{}:

@table @code
@item Date
Requires @vari{value} to be an exact integer in the range of the C
language type @code{signed long}; internally this value is converted to
@code{time_t}.  @varii{value} is ignored.

@item Message-Id
Requires @vari{value} to be a general C buffer holding an @asciiz{}
string; @vicareref{cbuffers strings, Introduction to generalised C
strings}.  @varii{value} is ignored.

@item From
@itemx Disposition-Notification-To
Require both @vari{value} and @varii{value} to be a general C buffer
holding an @asciiz{} string; @vicareref{cbuffers strings, Introduction
to generalised C strings}.

@item To
@itemx Cc
@itemx Bcc
@itemx Reply-To
@itemx Sender
Require both @vari{value} and @varii{value} to be a general C buffer
holding an @asciiz{} string; @vicareref{cbuffers strings, Introduction
to generalised C strings}.
@end table

If @var{header-name} is not specially recognised by @libesmtp{},
@vari{value} must be a general C buffer holding an @asciiz{} string;
@vicareref{cbuffers strings, Introduction to generalised C strings}.
@varii{value} is ignored.
@end defun


@defun smtp-set-header-option @var{message} @var{header-name} @var{option}
Select options for message header processing.  If successful return
@true{}, else return @false{}.

@var{header-name} must be a general C buffer holding an @asciiz{}
string; @vicareref{cbuffers strings, Introduction to generalised C
strings}.

@var{option} must be one of the constants: @code{Hdr_OVERRIDE},
@code{Hdr_PROHIBIT}.
@end defun


@defun smtp-set-resent-headers @var{message} @var{obj}
Set or unset special processing for headers which have a @code{Resent-}
variation.  If successful return @true{}, else return @false{}.
@end defun

@c page
@node plain status
@section Session results


The following bindings are exported by the library @library{vicare mail
libesmtp}.

@c ------------------------------------------------------------

@subsubheading Message delivery status


@defun smtp-message-transfer-status @var{message}
Return a struct instance of type @code{smtp-status} representing the
delivery status for @var{message}; if no status informations are
available: return @false{}.
@end defun


@defun smtp-reverse-path-status @var{message}
Return a struct instance of type @code{smtp-status} representing the
reverse path status for @var{message}; if no status informations are
available: return @false{}.
@end defun


@defun smtp-message-reset-status @var{message}
Reset the message status to the state it would have before
@func{smtp-start-session} is called for the first time on the containing
session.  If successful return @true{}, otherwise return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Recipient status


@defun smtp-recipient-status @var{recipient}
Return an instance of @code{smtp-status} representing the recipient
success/failure status from a previous @smtp{} session.  If no status
informations are available: return @false{}.
@end defun


@defun smtp-recipient-check-complete @var{recipient}
Check whether processing is complete for the specified recipient of the
message.  If complete return @true{}, otherwise return @false{}.
@end defun


@defun smtp-recipient-reset-status @var{recipient}
Reset the recipient status to the state it would have before
@func{smtp-start-session} is called for the first time on the containing
session.  If successful return @true{}, otherwise return @false{}.
@end defun


@c page
@node plain constants
@section Converting constants to symbols


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-event->symbol @var{constant}
Given an exact integer representing one of the @code{SMTP_EV_}
constants, return the corresponding symbol.
@end defun


@defun smtp-errno->symbol @var{constant}
Given an exact integer representing one of the @code{SMTP_ERR_}
constants, return the corresponding symbol.
@end defun


@defun smtp-timeout->symbol @var{constant}
Given an exact integer representing one of the @code{Timeout_}
constants, return the corresponding symbol.
@end defun


@defun smtp-cb->symbol @var{constant}
Given an exact integer representing one of the @code{SMTP_CB_}
constants, return the corresponding symbol.
@end defun


@defun smtp-hdr->symbol @var{constant}
Given an exact integer representing one of the @code{Hdr_} constants,
return the corresponding symbol.
@end defun


@defun smtp-notify->symbol @var{constant}
Given an exact integer representing one of the @code{Notify_} constants,
return the corresponding symbol.
@end defun


@defun smtp-e8bitmime->symbol @var{constant}
Given an exact integer representing one of the @code{E8bitmime_}
constants, return the corresponding symbol.
@end defun


@defun smtp-by->symbol @var{constant}
Given an exact integer representing one of the @code{By_} constants,
return the corresponding symbol.
@end defun


@defun smtp-starttls->symbol @var{constant}
Given an exact integer representing one of the @code{Starttls_}
constants, return the corresponding symbol.
@end defun


@defun smtp-ret->symbol @var{constant}
Given an exact integer representing one of the @code{Ret_} constants,
return the corresponding symbol.
@end defun


@defun auth->symbol @var{constant}
Given an exact integer representing one of the @code{AUTH_} constants,
return the corresponding symbol.
@end defun


@defun auth-plugin->symbol @var{constant}
Given an exact integer representing one of the @code{AUTH_PLUGIN_}
constants, return the corresponding symbol.
@end defun

@c page
@node plain data
@section Application data


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-set-application-data @var{session} @var{data-pointer}
Register a pointer object as application data associated to
@var{session}.  Return a pointer object.
@end defun


@defun smtp-get-application-data @var{session}
Return a pointer object referencing the application data associated to
@var{session}.
@end defun

@c ------------------------------------------------------------

@defun smtp-message-set-application-data @var{message} @var{data-pointer}
Register a pointer object as application data associated to
@var{message}.  Return a pointer object.
@end defun


@defun smtp-message-get-application-data @var{message}
Return a pointer object referencing the application data associated to
@var{message}.
@end defun

@c ------------------------------------------------------------

@defun smtp-recipient-set-application-data @var{recipient} @var{data-pointer}
Register a pointer object as application data associated to
@var{recipient}.  Return a pointer object.
@end defun


@defun smtp-recipient-get-application-data @var{recipient}
Return a pointer object referencing the application data associated to
@var{recipient}.
@end defun

@c page
@node plain extensions
@section @smtp{} extensions


@menu
* plain extensions auth::       AUTH extension.
* plain extensions starttls::   StartTLS extension.
* plain extensions deliver by:: Deliver By extension.
* plain extensions dsn::        Deliver Status Notification extension.
* plain extensions size::       Size extension.
* plain extensions 8bit::       8bit-MIME Transport extension.
* plain extensions etrn::       Remote Message Queue Starting (@etrn{})
                                extension.
@end menu

@c page
@node plain extensions auth
@subsection AUTH extension


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-gsasl-set-context @var{session} @var{gsasl-context}
Enable or disable @smtp{} @auth{} for @var{session}.  If successful
return @true{}, else return @false{}.

If @var{gsasl-context} is @false{}: @auth{} is disabled and the previous
@auth{} context, if any, is unregistered from @var{session}.  Else
@var{gsasl-context} must be a pointer object referencing a @code{Gsasl}
data structure.
@end defun


@defun smtp-auth-set-context @var{session} @var{auth-context}
@strong{This function is deprecated.}

Enable or disable @smtp{} @auth{} for @var{session}.  If successful
return @true{}, else return @false{}.

If @var{auth-context} is @false{}: @auth{} is disabled and the previous
@auth{} context, if any, is unregistered from @var{session}.  Else
@var{auth-context} must be an instance of @code{auth-context}.
@end defun

@c page
@node plain extensions starttls
@subsection StartTLS extension


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-starttls-enable @var{session} @var{how}
Enable or disable @smtp{} @code{STARTTLS} for @var{session}.  If
successful return @true{}, else return @false{}.

@var{how} must be an exact integer representing one of the
@code{Starttls_} constants.
@end defun


@defun smtp-starttls-set-ctx @var{session} @var{ssl-context}
Register an OpenSSL context in @var{session}.  If successful return
@true{}, else return @false{}.

@var{ssl-context} must be a pointer object referencing a foreign data
structure of type @code{SSL_CTX}.
@end defun


@defun smtp-starttls-set-password-cb @var{c-callback}
Register a single callback function to be used every time a password is
requested for OpenSSL operations.  If successful return @true{}, else
return @false{}.

@var{c-callback} must be @cnull{} or the return value of a call to
@func{make-smtp-starttls-passwordcb}.  Notice that this callback is
handed to @cfunc{SSL_CTX_set_default_passwd_cb} provided by the OpenSSL
library; @manpage{SSL_CTX_set_default_passwd_cb, set passwd callback for
encrypted @acronym{PEM} file handling}.
@end defun


@defun make-smtp-starttls-passwordcb @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as
@code{smtp_starttls_passwordcb_t} callback; the returned pointer must be
released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept @math{3} arguments:

@enumerate
@item
A pointer object referencing a memory buffer.

@item
An exact integer, in the range of the C language type @code{signed int},
representing the number of bytes available in the buffer.

@item
A boolean value: @true{} if the callback is used for reading/decryption,
@false{} if the callback is used for writing/encryption.
@end enumerate

@var{user-scheme-callback} must return an exact integer, in the range of
the C language type @code{signed int}, representing the actual length of
the password.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{0} to the caller.  @var{user-scheme-callback}
should take care of handling its own exceptions.
@end itemize
@end defun

@c page
@node plain extensions deliver by
@subsection Deliver By extension


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-deliverby-set-mode @var{message} @var{time} @var{by-mode} @var{trace}
Enable the Deliver By extension for @var{message}.  If successful return
@true{}, else return @false{}.

@var{time} must be an exact integer, in the range of the C language type
@code{signed long}.

@var{by-mode} must be an exact integer representing one of the constants
@code{By_}.

@var{trace} must be an exact integer, in the range of the C language
type @code{signed int}.
@end defun

@c page
@node plain extensions dsn
@subsection Deliver Status Notification extension


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-dsn-set-ret @var{message} @var{flags}
Instruct the reporting @acronym{MTA} whether to include the full content
of the original message in the Delivery Status Notification, or just the
headers.  If successful return @true{}, else return @false{}.

@var{flags} must be an exact integer representing one of the constants
@code{Ret_}.
@end defun


@defun smtp-dsn-set-envid @var{message} @var{envelope-identifier}
Set the envelope identifier; this value is returned in the @acronym{DSN}
and may be used by the @acronym{MUA} to associate the @acronym{DSN} with
the message that caused it to be generated.  If successful return
@true{}, else return @false{}.

@var{envelope-identifier} must be a general C buffer holding an
@asciiz{} string; @vicareref{cbuffers strings, Introduction to
generalised C strings}.
@end defun


@defun smtp-dsn-set-notify @var{recipient} @var{flags}
Set the @acronym{DSN} notify options.  If successful return @true{},
else return @false{}.

@var{flags} must be an exact integer represneting the
@code{Notify_NOTSET} or @code{Notify_NEVER} or the bitwise OR
combination of any of @code{Notify_SUCCESS}, @code{Notify_FAILURE} and
@code{Notify_DELAY}.
@end defun


@defun smtp-dsn-set-orcpt @var{recipient} @var{address-type} @var{address}
Set the @acronym{DSN} @code{ORCPT} option.  If successful return
@true{}, else return @false{}.

@var{address-type} and @var{address} must be general C buffers holding
an @asciiz{} string; @vicareref{cbuffers strings, Introduction to
generalised C strings}.
@end defun

@c page
@node plain extensions size
@subsection Size extension


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-size-set-estimate @var{message} @var{size}
Set an estimate of the size of the message to be transferred.  If
successful return @true{}, else return @false{}.

@var{size} must be an exact integer, in the range of the C language type
@code{unsigned long}, representing the message size.
@end defun

@c page
@node plain extensions 8bit
@subsection 8bit-MIME Transport extension


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-8bitmime-set-body @var{message} @var{body}
Specify the body type.  If successful return @true{}, else return
@false{}.

@var{body} must be an exact integer representing one of the constants
@code{E8bitmime_}.
@end defun

@c page
@node plain extensions etrn
@subsection Remote Message Queue Starting (@etrn{}) extension


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun smtp-etrn-add-node @var{session} @var{option} @var{node}
Add an @code{ETRN} node to the @smtp{} session.  If successful return an
instance of @code{smtp-etrn-node}, else return @false{}.

@var{node} must be a general C buffer holding an @asciiz{} string;
@vicareref{cbuffers strings, Introduction to generalised C strings}.
@end defun


@defun smtp-etrn-enumerate-nodes @var{session} @var{c-callback}
For each @code{smtp_etrn_node_t} in the @code{smtp_sesssion_t}
referenced by @var{session}: call the @var{c-callback} function.  If
successful return @true{}, else return @false{}.

@var{c-callback} must be the return value of a call to
@func{make-smtp-etrn-enumerate-nodecb}.
@end defun


@defun make-smtp-etrn-enumerate-nodecb @var{user-scheme-callback}
Wrap a user supplied Scheme function and return a pointer object
referencing a callback function suitable to be used as
@code{smtp_etrn_enumerate_nodecb_t} callback; the returned pointer must
be released with a call to @func{free-c-callback} from @library{vicare
ffi}.

@var{user-scheme-callback} must accept @math{3} arguments:

@enumerate
@item
An instance of @code{smtp-etrn-node} referencing a node.  This instance
is @strong{not} an object returned by @func{smtp-etrn-add-node}.

@item
An exact integer, in the range of the C language type @code{signed int},
representing the option argument.

@item
A pointer object referencing the domain as @asciiz{} string.  Such
string can be converted to Scheme with a call to @func{cstring->string}
from @library{vicare ffi}.
@end enumerate

@var{user-scheme-callback} can return unspecified values.

@var{user-scheme-callback} is wrapped in an internally generated Scheme
function which does the following:

@itemize
@item
Block and discard all the raised exceptions using @func{guard} from
@library{vicare}; when an exception is catched: it is discarded and the
callback returns @code{(void)} to the caller.
@var{user-scheme-callback} should take care of handling its own
exceptions.
@end itemize
@end defun


@defun smtp-etrn-enumerate-nodes @var{session} @var{scheme-callback}
Apply @var{scheme-callback} to each @code{smtp-etrn-node} registered in
@var{session}; return unspecified values.  The order of application is
undefined.

@var{scheme-callback} must be a Scheme procedure accepting a single
argument: an instance of @code{smtp-etrn-node} registered in
@var{session}.  The @code{smtp-etrn-node} instances handed to
@var{scheme-callback} are the same returned by
@func{smtp-etrn-add-node}.
@end defun


@defun smtp-etrn-node-status @var{etrn-node}
Retrieve the @etrn{} node success/failure status from a previous @smtp{}
session.  If successful return a @code{smtp-status} instance, otherwise
return @false{}.
@end defun


@defun smtp-etrn-set-application-data @var{etrn-node} @var{data-pointer}
Associate a pointer object to an @etrn{} node structure.
@end defun


@defun smtp-etrn-get-application-data @var{etrn-node}
Return the data pointer associated to an @etrn{} node structure.
@end defun

@c page
@ignore
@node plain auth
@section @auth{} module


The following bindings are exported by the library @library{vicare mail
libesmtp}.


@defun auth-client-init

@end defun


@defun auth-client-exit
@end defun


@defun auth-create-context
@end defun


@defun auth-destroy-context
@end defun


@defun auth-set-mechanism-flags
@end defun


@defun auth-set-mechanism-ssf
@end defun


@defun auth-set-interact-cb
@end defun


@defun auth-client-enabled
@end defun


@defun auth-set-mechanism
@end defun


@defun auth-mechanism-name
@end defun


@defun auth-response
@end defun


@defun auth-get-ssf
@end defun


@defun auth-encode
@end defun


@defun auth-decode
@end defun


@defun auth-set-external-id
@end defun

@end ignore

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @url{http://marcomaggi.github.com/docs/vicare-libesmtp.html}

@noindent
the latest version of this package can be downloaded from:

@center @url{http://code.google.com/p/vicare-scheme/downloads/list}

@noindent
development takes place at:

@center @url{http://github.com/marcomaggi/vicare-libesmtp/}

@noindent
the home page of the Vicare project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
the home page of the Nausicaa project is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
@libesmtp{} can be found here:

@center @value{LIBESMTP_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

